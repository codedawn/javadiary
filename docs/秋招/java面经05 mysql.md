聚簇索引：innodb中主键索引的叶子节点直接存放数据，根据索引直接找到

数据



![img](https://upload-images.jianshu.io/upload_images/3190591-fdd992e6ec02ef06.png?imageMogr2/auto-orient/strip|imageView2/2/w/662/format/webp)





脏读 读到未提交的数据
不可重复读 同一事务，两次读取数据不一样
幻读 读取数据时，另一个事务插入记录，多了原本不存在的数据

读未提交 可以读取到未提交的数据，会有脏读，不可重复读，幻读
读已提交 可以读取提交了的数据，可以避免脏读，但是还是会有不可重复读和幻读
可重复读 可以避免脏读和不可重复读和幻读
串行化 可以避免脏读和不可重复读和幻读





通过explain分析sql语句的性能



ACID

atomic 原子性

consistency 一致性

isolation 隔离性

durability 持久性



索引：

主键索引

唯一索引

普通索引

全文索引

联合索引



红黑树容易添加修改，平衡次数比avltree少，到达空叶子（nil）节点经过相同的黑色节点

b+树高度低



innodb行锁

共享锁：又称读锁，如果一个行加了读锁，那么所有事务都不可以修改，只能读

排它锁：一个行加了排它锁，那么其他事务就不能加锁，只有当前事务可以读取和修改行，





innodb引擎，对于update、insert、delete都会加排它锁

select默认不加锁

innodb默认是行锁，是对索引加锁，所以索引不生效时，会升级为

表锁

select 想加s锁

select 语句 + lock in share mode





select 想加排它锁

select语句+ for update

[MYSQL（04）-间隙锁详解 - 简书 (jianshu.com)](https://www.jianshu.com/p/32904ee07e56)

范围查询时，范围内不存在的数据加间隙锁

where id<10

1

2

3

4



5 6 7 8 9加间隙锁，不能插入

防止幻读

如果使用相等条件请求给一个不存在的记录加锁，

InnoDB也会使用间隙锁！

间隙锁不互斥，就是两个select where都可以加间隙锁

varchar 类型索引

查询是不加引号

比如 name=‘100’  和name=100

后者不会走索引，mysql会自动进行类型转换，但是不会走索引

一旦对索引字段做函数操作，MySQL 会放弃使用索引。

所以不要对索引进行函数操作，需要索引时

[新来的实习生把数据库搞炸了...... - 51CTO.COM](https://database.51cto.com/art/202007/622022.htm)



b+树比b树进一步降低了高度

而且叶子节点是双链表连接，范围查找性能更好

时间复杂度更稳定 log2n







事务的四大特性：

原子性 atomic

一致性 consistency

隔离性 isolation

持久性 durability





第一范式 字段原子性，不可再分

第二范式 必须有主键，非主键必须完全依赖主键，不能部分依赖

第三范式 在二的基础上，必须直接依赖主键，不能间接依赖



脏读：在事务中读到未提交的数据

不可重复读：在一个事务内，多次查询得到不同的数据，说明读到了另一个事务已经提交的数据

幻读：在读取范围行数据时，其他事务插入事务，然后在事务提交之前，查不到这行数据（以为不存在），但是却插入不了，像幻想一样存在着一条数据（事实是存在的，但是当前事务读不到）

[事务已提交另外会话查询不到的问题解析 - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1072087)

![image-20211022124703906](C:\Users\11096\AppData\Roaming\Typora\typora-user-images\image-20211022124703906.png)



读未提交：可以读到未提交的数据

读已提交：只能读提交了的数据

可重复读：解决不可重复读的问题，行加锁

串行化：事务顺序执行



索引：

数据结构，组织数据的，提高查询性能



优点：

1.加快数据查找速度

缺点：

1.建立索需要消耗额外的物理空间，然后加载索引到内存需要占用内存

2.需要维护索引，增删改索引会变化



b+树高度一般在2到4层



什么情况建索引：

1.经常用于查询

2.经常用于连接的字段

3.经常需要排序的字段建立索引，因为索引是排好序的



什么情况下不建立索引：

1.where条件中用不到的

2.表记录少

3.经常增删查改的，这样索引维护就消耗太大

4.参与列计算的，函数运算后，不走索引

5.区分度不高，就是重复度高的，比如性别



哈希表不支持排序，不支持范围查找、不支持模糊查询

还会有hash冲突



为什么b+树比b树更适合做索引

1。b+树所有的数据都存储在叶子节点，所以性能是稳定的

然后叶子之间可以组织成双向链表，这链表是有序的

而b树需要中序遍历，才得到有序序列

2.b+树的节点只存储索引 的key值，具体的数据存在于叶子节点

这就使以页为单位的索引中可以存放更多的节点。减少更多的io支出

3.b+树更加稳定，任何关键字都需要查询到叶子，每个数据的

查询效率相当



索引有什么分类？

1.主键索引：名为

primary的唯一非空索引，不允许有空值	



2.唯一索引：索引值必须唯一，但是可以有空值，并且可以存放多个空值

3.组合索引：在表中的多个字段组合上创建的索引，遵循最左前缀原则

4.全文索引：

聚集索引：



覆盖索引：

select的数据列可以直接在索引中得到，不需要回表主键索引





索引的设计原则：

索引的区分度越高，效果越好

尽量使用短索引，io较少，空间较少

索引不是越多越好

利用最左前缀原则



索引什么时候失效：

1.联合索引使用时，不符合最左前缀原则

2.like，like %x，不会走索引，like x%会走

3.字符串没有使用引号，会发送隐式转换，函数操作，不走索引

4.对索引列进行运算

5.查询条件使用or，也会使用失效



[(18条消息) MySQL中MVCC的正确打开方式（源码佐证）_Waves___的博客-CSDN博客](https://blog.csdn.net/Waves___/article/details/105295060#1.2、Read View 结构)

为了避免加锁，

使用mvcc multi-version-concurrency control

每个连接在某个瞬间看到的是数据库的一个快照

写者写操作在完成前，其他连接不可见

mvcc 不会直接用新数据覆盖旧数据，而是标记为过时

然后在别处增加新版本数据，这样就有存储多个版本的数据

但是只有一个最新，然后之前连接读的数据不受影响，需要定期更新这些额外的花销

mvcc会根据时间戳或事务id标记数据库的版本，

读写相互隔离，不需要加锁。读写并存会根据数据库的状态

创建一个新版本

并发的读则依旧访问旧版本的数据

mvcc有关的两个隐藏列

数据行的版本号（db-trx-id）

删除版本号（db_roll_pt）

插入是获取事务的全局id，最开始是1.所以数据行的版本号是1

![image-20211026234227820](C:\Users\11096\AppData\Roaming\Typora\typora-user-images\image-20211026234227820.png)

删除时获取事务的全局id

填到删除版本号



修改时，会把全局事务id填到数据行版本号



MVCC 查询

查找数据行版本号早于当前事务版本号，说明是之前的版本

查找删除版本号为null，要么大于当前事务版本号的记录

确认查询处理的数据行没有被删除

Rdb和aof

一个是快照和增量，就是每次写命令

aof恢复满，但是更完整，文件更大

rdb安全性差，恢复快，但是可能会丢失数据

redis 4.0使用混合持久化

默认redis有16个数据库



![image-20211031154130709](C:\Users\11096\AppData\Roaming\Typora\typora-user-images\image-20211031154130709.png)

历史记录的保存在undolog

readview，判断当前事务可以读那个版本数据，相当于

生成一个当前事务的快照数据

trx_ids:记录正活跃的事务列表

low limit id，下一个事务id

up limit id 活跃列表中最小事务的id

因为trx_ids是逆序的，所以最后一个最小



rc是每一次快照读都会创建一个readview

rr是是第一个快照读创建，后面都是同一个

[MySQL 主从复制原理不再难 - rickiyang - 博客园 (cnblogs.com)](https://www.cnblogs.com/rickiyang/p/13856388.html)



主mysql 一个log dump thread

从mysql 一个io线程，一个sql线程



主库会把命令写到binlog，然后从库io线程会请求主mysql的binlog，这时binlog会上锁

然后从库写入到relay log中，从库再读取进行执行

redo log 是innodb特有的





mvcc实现原理



#### mysql语句执行流程

连接器

查询缓存

分析器（语义化解析）

优化器

执行器





1.违背最左前缀原则

2.在索引上进行函数操作，比如字符串类型不加单引号，会自动进行类型转换，不走索引

3.like通配符在开头：%123

4.使用or不一定走索引，











